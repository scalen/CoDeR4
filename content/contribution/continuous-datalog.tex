\begin{nestedsection}{Continuous Datalog}{semantics}
The first requirement of stream reasoning is a well-defined semantics.
that takes into account both the continuous nature of a subset of the
base axioms of a stream reasoning problem, as well as its
instantaneous truth and entailments, in line with the work of the
reasoning community.  However, it must also provide a continuous
interpretation of those instantaneous entailments in order to
integrate with other stream-processing technologies.  More
specifically, an appropriate semantics for stream reasoning on the
Semantic Web must: allow the expression of OWL 2 ontologies to some
degree of expressivity; not sacrifice the precise semantics thereof
whilst incorporating the semantics of stream processing; and allow for
the continuous derivation of entailments in a concise manner.

Continuous Datalog (henceforth C-Datalog) is an extension of positive
Datalog with stream-processing semantics, with a view to accommodating
the aims of the latter within the well-defined model-theoretic
semantics of the former, which are shared with RIF-Core
\cite{w3crifbld} and therefore support reasoning at the expressivity
of OWL 2 RL. As part of its application to Semantic Web reasoning, we
assume that the atomic formulae of the Datalog programs described
below correspond to RDF triples: $\langle subj, pred, obj\rangle$.

C-Datalog differs from conventional Datalog through the addition of
sources of continuously generated or reported facts (i.e streams), and
the application of sliding window semantics over those sources,
thereby providing for the interpretation of Continuous Datalog
programs as sequences of instantaneous states that are each valid
positive Datalog programs.  As such, these states each inherit the
semantics of positive Datalog.  Furthermore, it involves the
continuous derivation of entailments from this sequence of
instantaneous states as a set of streams of facts; these streams share
a data model with the streams of continuous queries, as defined by the
stream processing community, thereby allowing the integration of
Continuous Datalog programs into stream processing pipelines.

In addition, we show that these streams may be manipulated to retrieve
the instantaneous sets of entailments produced by the more
semantically well-defined offerings from the reasoning community.

%%% what does this mean? ^

\begin{definition}[Datalog]
\labeldef{continuous datalog: datalog program}

A conventional Datalog program $\Pi = \langle R, F\rangle$ comprises a
set of clauses, divided into a finite set of rules $R$ and a finite
set of ground facts $F$. Facts are formulae of first-order logic, and
rules are of the form:

\[ \alpha_0 \Leftarrow \alpha_1 \land \ldots \land \alpha_n \]

\noindent where $\alpha_i$ are atomic formulae. Note that we have excluded any
universally quantified variables for clarity.

The Herbrand base $\hat{H}$ of $\Pi$ is the set of all facts that can
be expressed using the predicates in $\Pi$; for a program $\Pi =
\langle R, F \rangle$, $F \subseteq \hat{H}$. Note that we do not
distinguish between the predicates in $F$ and those in the heads of
the rules in $R$ (as extensional and intensional predicates), as is
the case in the model theory for Datalog presented in
\cite{datalog-basics}; in this respect, our treatment follows that of
the model theory for Prolog presented in \cite{prolog-semantics}. A
Herbrand interpretation $\mathcal{I}$ of $\Pi$ is any subset of
$\hat{H}$, and a Herbrand interpretation $\mathcal{I}$ that satisfies
the set of clauses in program $\Pi$ is a Herbrand model of $\Pi$,
written $\models_{\mathcal{I}} \Pi$.

We define the concept of entailment in Datalog as follows. A fact $e$
is entailed by a program $\Pi$ iff each interpretation satisfying
$\Pi$ (satisfying every clause in $\Pi$) also satisfies $e$, written
$\Pi \models e$. For a program $\Pi$ and a set of entailed facts
$E$, $\Pi \models E$ iff $\Pi \models e$ for every $e \in E$. For
convenience, we refer to the set of all facts that are entailed by a
program (the intersection of all the Herbrand models of the program)
as the {\em entailment of a program}, written $cons(\Pi)$ and defined
as:
\begin{align*}
  cons(\Pi) &= \{ e \in \hat{H} \mid \Pi \models e \} \\
  &= \bigcap_\mathcal{I} \models_\mathcal{I} \Pi
\end{align*}
\end{definition}

\begin{definition}[Justification]
\labeldef{continuous datalog: justification}

We define a {\em justification} of a set of facts that are entailed by
a Datalog program as a minimal subset of the program that is
sufficient for the entailment to hold. More precisely, for a Datalog
program $\Pi = \langle R, F \rangle$ and a set of entailed facts $E$
where $\langle R, F \rangle \models E$, the program $\langle J_R, J_F
\rangle$ with $J_R \subseteq R$ and $J_F \subseteq F$ is a
justification for $E$ iff $\langle J_R, J_F \rangle \models E$ and,
for all $J'_R \subset J_R$ or $J'_F \subset J_F$, $\langle J'_R, J'_F
\rangle \not\models E$.

We simplify this notion of justification by making the assumption that
a justification can be defined in terms of a minimal subset of the
ground facts of the program; the rules of the program are therefore
implicitly considered to be part of every justification. Any
subsequent references to {\em justification} are to this simplified
sense, which is defined as follows: given a Datalog program $\Pi =
\langle R, F \rangle$ and a set of entailed facts $E$ where $\langle
R, F \rangle \models E$, the set of facts $J \subseteq F$ is a
justification for $E$ iff $\langle R, J \rangle \models E$ and, for
all $J' \subset J$, $\langle R, J' \rangle \not\models E$. Note that a
given set of entailed facts may not have a unique justification.

\end{definition}

\begin{definition}[Time Domain]
\labeldef{continuous datalog: instant}

Let $\mathbb{T}$ be a discrete time domain with a total order under
$\leqslant$; an element of $\mathbb{T}$ is an {\em instant}.
$\mathbb{T}$ has a lower bound $0$, such that for all $i \in
\mathbb{T}$, $0 \leqslant i$. For convenience, we write $i+n$ where $i
\in \mathbb{T}$ to indicate the $n$th successor of instant $i$,
and $i-n$ to indicate the $n$th predecessor of instant $i$.

\end{definition}

\begin{definition}[Fact Instance]
 \labeldef{continuous datalog: fact instance}

A {\em fact instance} is a fact with some additional temporal
annotation; it is a tuple containing a fact $f$ and an instant $t \in
\mathbb{T}$, written $\langle f, t \rangle$. Two fact instances
containing the same fact and timestamp are considered identical; two
fact instances containing the same fact but different timestamps are
considered to be distinct.

We represent the relationship between a fact (without temporal
annotation) and a fact instance (with temporal annotation) with the
function $strip()$ which maps a fact instance to its underlying fact:
\[ strip(\langle f, t\rangle) = f \]

For convenience, we also write $strip(F^T) = F$, where $F^T$ is a set
of fact instances and $F = \{ strip(f) \mid f \in F^T \}$.

\end{definition}

In \refdef{continuous datalog: datalog program}, we took a Datalog
program to consist of a set of rules and a set of facts.  In order to
extend this definition of Datalog programs to incorporate fact
instances, we define a Time-Annotated Datalog program as follows:

\begin{definition}[Time-Annotated Datalog]
\labeldef{continuous datalog: ta datalog program}

A Time-Annotated Datalog program (henceforth abbreviated TA-Datalog)
$\Pi^T = \langle R, F^T\rangle$ is a tuple which comprises a finite
set of rules $R$ and a finite set of fact instances $F^T \subseteq
\hat{H} \times \mathbb{T}$. Fact instances are as defined in
\refdef{continuous datalog: fact instance}, and rules are of the same
form as in conventional Datalog programs.

When considering a TA-Datalog program, in which there may be many
distinct instances of a given fact, temporal information regarding
when instances of that fact became true would be lost if such a
program were to entail sets of plain facts without temporal
annotations. We therefore extend the model theory for Datalog from
\refdef{continuous datalog: datalog program} by considering the
Herbrand base of all fact instances $\hat{H}^T$ (all facts at all
instants). As before, a fact instance $e$ is entailed by a program
$\Pi^T$ iff each interpretation satisfying every clause in $\Pi^T$
also satisfies $e$, written $\Pi^T \models e$. The {\em entailment of the
program} $\Pi^T$ is therefore:
\[ cons^T(\Pi^T) = \{ e \in \hat{H}^T \mid \Pi^T \models e \} \]

Informally, the set of instants appearing in some set $E^T$ of fact
instances entailed by some program ${\langle R, F^T \rangle}$ will be
a subset of the instances appearing the fact instances in $F^T$.  In
addition, the instant $t$ in a fact instance $\langle e, t \rangle$
that is entailed by a TA-Datalog program $\Pi^T = \langle R^T, F^T
\rangle$ will be bounded from above by the maximum instant in any fact
instance in $F^T$. A TA-Datalog program may entail fact instances that
are only distinguished by their instants (and are therefore considered
distinct from each other, as per \refdef{continuous datalog: fact
  instance}).

Consider the following example TA-Datalog program:
\[
\Pi^T = \langle \{ c \Leftarrow a \land b \}, \{ \langle a, 1 \rangle, \langle a, 2 \rangle, \langle b, 1 \rangle, \langle b, 2 \rangle  \} \rangle
\]

The entailment of the program $\Pi^T$ will be:
\[cons^T(\Pi^T) = \{\langle c, 1 \rangle, \langle c, 2 \rangle\}\]

It follows that applying the ${strip()}$ function to all the fact
instances in both the set of fact instances $F^T$ in some ${\Pi^T =
  \langle R, F^T \rangle}$ and the entailment of the program $\Pi^T$
(the set of fact instances $cons^T(\Pi^T)$) maintains the relationship
of entailment; if $\langle R, F^T\rangle \models \langle e, t
\rangle$, then $\langle R, strip(F^T) \rangle \models strip(\langle e,
t \rangle)$. This relationship is shown in \reffig{TD-D}.

\begin{figure}[htb]
  \[
  \begin{CD}
\Pi^T = \langle R, F^T \rangle @>\models>> cons^T(\Pi^T) \\
@V{strip}VV @V{strip}VV \\
\Pi = \langle R, F \rangle @>\models>> cons(\Pi)
  \end{CD}
  \]
\caption{Relationship between Datalog and TA-Datalog entailments}
\labelfig{TD-D}
\end{figure}

Reconsidering the example TA-Datalog program above, we may convert it
into the following equivalent conventional Datalog program $\Pi$:
\begin{align*}
\Pi &= \langle \{ c \Leftarrow a \land b \}, strip(\{ \langle a, 1 \rangle, \langle a, 2 \rangle, \langle b, 1 \rangle, \langle b, 2 \rangle \}) \rangle \\
    &= \langle \{ c \Leftarrow a \land b \}, \{ a, b \} \rangle
\end{align*}
Trivially, the entailment of this program $\Pi$ will therefore be:
\begin{align*}
cons(\Pi) &= strip(\{\langle c, 1 \rangle, \langle c, 2 \rangle\}) \\
 &= \{ c \}  
\end{align*}
\end{definition}

\begin{definition}[Time-Annotated Justification]
\labeldef{continuous datalog: instance justification}

The justification of entailments is equally applicable to TA-Datalog
programs, with facts in the entailment and the justification for that
entailment being replaced with fact instances.  Following the
simplified notion of justification in \refdef{continuous datalog:
  justification}, we define the justification of a set of fact
instances that are entailed by a TA-Datalog as a minimal subset of
the ground fact instances of the program that are sufficient for
the entailment to hold.

More formally, for a TA-Datalog program $\Pi^T = \langle R, F^T \rangle$
and a set of entailed fact instances $E^T$ where $\langle R, F^T \rangle \models E^T$, the set of fact instances $J^T \subseteq F^T$ is a justification for
$E^T$ iff $\langle R, J^T \rangle \models E^T$ and, for all $J^{T\prime} \subset J^T$, $\langle R, J^{T\prime} \not\models E^T$.

For an entailed fact instance $\langle e, t\rangle$ and a
justification of that fact instance $J^T$, the instant $t$ at which
$\langle e, t \rangle$ becomes true is take to be the latest instant
at which any of the fact instances in the justification became true:
\[ t = max(\{ t' \mid \langle j', t' \rangle \in J^T \}) \]

Note that, although an entailed fact instance $\langle e, t\rangle$
may have multiple justifications, all the justifications for $\langle
e, t \rangle$ will share the same maximum instant; a justification
with a different maximum instant $t' \neq t$ would entail a different
fact instance $\langle e, t' \rangle$. Considering again the example
TA-Datalog program in \refdef{continuous datalog: ta datalog program},
the entailed fact instance $\langle c, 2 \rangle$ would have the
following set of justifications:
\[
  \{ \ \{ \langle a, 1 \rangle, \langle b, 2 \rangle \},  \{ \langle a, 2 \rangle, \langle b, 1 \rangle \},  \{ \langle a, 2 \rangle, \langle b, 2 \rangle \} \  \}
\]

\end{definition}

Having defined the notion of time annotation in Datalog, we now define
the notions of streams and windows before extending to Continuous Datalog.

\begin{definition}[Streams]
\labeldef{continuous datalog: stream}

A {\em stream} is an unbounded sequence of fact instances ordered by
their instants; the instants are non-decreasing in the stream, such
that for any two fact instances $\langle f_i, t_i \rangle$ and
$\langle f_j, t_j\rangle$ where the former appears on the stream
  before the latter, $t_i \leqslant t_j$.
\end{definition}

\begin{definition}[Window]
\labeldef{continuous datalog: window}

A window of range ${x \in \mathbb{N}}$ over a stream $S$ at an instant
${i \in \mathbb{T}}$ is the \emph{set} of fact instances that occur in
$S$ during the interval ${(i-x,i]}$, written ${W^{S,x}_{i}}$, and
defined as follows:
\[ W^{S,x}_i = \{ \langle f, t \rangle \mid \langle f, t \rangle \in S \land (i-x) < t \leqslant i \}\]  
\end{definition}

The following axioms define the semantics of streams and windows over
those streams in Continuous Datalog:

\begin{axiom}\label{axiom:continuous datalog: window range leq 0}
A window of range $0$ over a stream $S$ at an instant 
${i \in \mathbb{T}}$ is always empty.
\begin{equation*}
W^{S,0}_{i} = \varnothing
\end{equation*}
\end{axiom}

\begin{axiom}\label{axiom:continuous datalog: window composition}
A window of range ${x > 0}$ over a stream $S$ at an instant 
${i \in \mathbb{T}}$ is equal to the union of the $x$ consecutive
windows of range $1$ over the stream $S$ preceding and including that at
instant $i$.
\begin{equation*}
W^{S,x}_{i} = \mathop{\cup}_{j=0}^{x-1} W^{S,1}_{i-j}
\end{equation*}
\end{axiom}

\begin{axiom}\label{axiom:continuous datalog: window disjointness}
A window of range ${x \in \mathbb{N}}$ over a stream $S$ at an
instant ${i \in \mathbb{T}}$ is disjoint from a second window of 
range ${y \in \mathbb{N}}$ over $S$ at any instant before $i - x$.
\begin{equation*}
W^{S,x}_{i} \cap W^{S,y}_{i-z} = \varnothing
\end{equation*}
where $z \geq x$.
\end{axiom}


From this description of instance entailment,
Axiom~\ref{axiom:continuous datalog: entailment disjointness} may be
derived:


\begin{axiom}\label{axiom:continuous datalog: entailment disjointness}
  If two sliding windows over the same stream $S$ cover non-overlapping time periods,
then a set $E^T_1$ of fact instances entailed by ${\langle R, W^{S,x}_i \rangle}$
is necessarily disjoint from any set $E^T_2$ of fact instances entailed by
$\langle R, W^{S,y}_{i-z} \rangle$, where ${z \geq x}$.
% This is because the timestamps of the instances ${E^T1}$ are a subset of those of
% the instances $W^{S,x}_i$, the timestamps of the instances ${E^T2}$ are a subset
% of those of the instances $W^{S,y}_{i-z}$, fact instances are distinct by timestamp and
% ${\{ t : f | t \in W^{S,x}_i\} \cap \{ t : f | t \in W^{S,y}_{i-z}\} = \varnothing}$.
\[
\{ e : \langle R , W^{S,x}_i \rangle \vdash e \} \cap \{ e : \langle R , W^{S,y}_{i-z} \rangle \vdash e \} = \varnothing
\]
\end{axiom}

Given these definitions, a Continuous Datalog program may be formally
defined, both in terms of streams and in terms of its instantaneous
states:

\begin{definition}[Continuous Datalog Program]
\labeldef{continuous datalog: CDP}

A Continuous Datalog program (henceforth abbreviated C-Datalog)
$\Pi^C = \langle R, F^0, S, r \rangle$ is a tuple which comprises a
finite set of rules $R$, a finite set of static fact instances $F^0$
(all of which have the instant $0$), a stream $S$ and a range
${r \in \mathbb{N}}$ for a window over $S$.

%This specifies that the streamed instances from $S$
%are to be considered valid from their timestamp for the duration
%represented by $r$.

We consider the entailment of the program $\Pi^C$ not just
as a set of fact instances (as for TA-Datalog), but in three parts: a
set of fact instances $E^0$ entailed by the fact instances in $F^0$, a
stream $P$ of fact instances entailed by the fact instances in $F^0$
and S, and a stream $N$ of fact instance negations: $\langle R, F^0,
S, r \rangle \models \langle E^0, P, N \rangle$. $P$ and $N$ can be
considered to be the continuous reasoning equivalents of the streams
produced by the \emph{IStream} and \emph{DStream} operators
respectively of the \emph{CQL} continuous query language \citep{CQL},
which create streams based on the additions to and deletions from a
relation.

In order to 

\end{definition}

\begin{definition}[Instanteous State of a C-Datalog program]
\label{def:continuous datalog: CDPt}

Given a C-Datalog program $\Pi^C$, we can 

The truth value of a $\Pi^C$ is instantaneous, with the the truth
function of Continuous Datalog $T^{CD}$ taking both a program ${\Pi^C}$
and an instant ${i \in \mathbb{N}}$ as arguments.


The state of a $\Pi^C$ at a given instant $i$ is the time-annotated
Datalog program ${\Pi^C_i = \langle R, F^0 \cup W^{S,r}_{i} \rangle}$,
where ${F^0 = \{ f | 0 : f \in F \}}$ is the set of persistent fact instances produced by
annotating each fact in $f$ in $F$ as becoming true at the first recognised instant.

As both $F$ and ${W_i = \{ strip(x) : x \in W^{S,r}_{i} \}}$ are sets of conventional
Datalog facts, the tuple ${\langle R, F \cup W_i}$
constitutes a valid Datalog program that may be evaluated by the truth
function of Datalog $T^{D}$, the result of which is the definition for the
instantaneous truth of $\Pi^C$ at instant $i$ by $T^{CD}$.
\begin{multline*}
T^{CD} \left( \langle R, F, S, r \rangle, i \right) = \\
	T^{D} \left( \langle R, F \cup \{ strip(x) : x \in W^{S,r}_{i} \} \right)
\end{multline*}

The instantaneous entailments of a $\Pi^C_i$ are the union of the set of
persistent entailments of ${\langle R, F^0 \rangle \vDash E^0}$ (which are
guaranteed to be entailed by every state, as positive Datalog is monotonic),
and the set $E^T_{i}$ of transient entailments whose justifications are at
least partially contained in $W^{S,r}_i$.
\begin{equation*}
\Pi^C_i = \langle R, F^0 \cup W^{S,r}_{i} \rangle \vDash E^0 \cup E^T_{i}
\end{equation*}
$E^T_i$ is defined more formally as
${E^T_{i} = \{ x : \left( \Pi^C_i \vdash x \right) \wedge
\left( just(\Pi^C_i,x) \cap W^{S,r}_i \neq \varnothing \right) \}}$.
By this definition and Axiom~\ref{axiom:continuous datalog: entailment disjointness},
$E^0$ is guaranteed to be disjoint from every $E^T_i$
for every state $\Pi^C_i$ of every Continuous Datalog Program $\Pi^C$.
\end{definition}

The following axioms define the semantics of the streams of
entailments $P$ and and negations $N$ of a $\Pi^C$ in terms of the
instantaneous entailments of the sequence of states of that continuous
program.

\begin{axiom}
\label{axiom:continuous datalog: positive window increment}
The window of range 1 at any given instant ${i \in \mathbb{N}}$ over
the stream $P$ entailed by a $\Pi^C$ is defined as the set of fact instances
that are entailed by the state of the $\Pi^C$ at instant $i$ that were
not entailed by the state of $\Pi^C$ at the previous instant ${i-1}$.
\begin{equation*}
W^{P,1}_{i} = \left( E^0 \cup E^T_{i} \right) \setminus
\left( E^0 \cup E^T_{i-1} \right) = E^T_{i} \setminus E^T_{i-1}
\end{equation*}
\end{axiom}
\begin{axiom}
\label{axiom:continuous datalog: negative window increment}
The window of range 1 at any given instant ${i \in \mathbb{N}}$ over
the stream $N$ entailed by a $\Pi^C$ is defined as the set of fact instances
that were entailed by the state of the $\Pi^C$ at the previous instant
${i-1}$ that are no longer entailed by the state of $\Pi^C$ at instant $i$.
\begin{equation*}
W^{N,1}_{i} = \left( E^0 \cup E^T_{i-1} \right) \setminus
\left( E^0 \cup E^T_{i} \right) = E^T_{i-1} \setminus E^T_{i}
\end{equation*}
\end{axiom}

\begin{axiom}
\label{axiom:continuous datalog: entailment precedes negation}
Fact instances may only be negated by some part of their justification leaving
the sliding window $W^{S,r}_{i}$, this necessarily being after they
were entailed.  As such, a window of any range ${x \in \mathbb{N}}$
over the stream of entailments $P$ at any given instant ${i \in \mathbb{N}}$
is disjoint from a window of any range ${y \in \mathbb{N}}$ over the
stream of entailment negations $N$ at any instant before ${i - x}$.
\begin{equation*}
W^{P,x}_{i} \cap W^{N,y}_{i-z} = \varnothing
\end{equation*}
where $z \geq x$.
\end{axiom}

From this, we can see that each entailed fact instance ${f|t}$ in some
$E^T_{i}$, of the form ${f|t = \langle s, p, o \rangle | t}$, has a
timestamp $t$ that is the real-time associated with the state
$\Pi^C_{i_{e}}$ in which its particular justification for ${f|t}$ is
first complete. As such, the stream of entailed fact instances $P$ of
a $\Pi^C$ takes precisely the same form as the streams of facts already
described, thus producing a concise stream of entailments that may be
read by further stream processing.  In addition, the stream of negations
$N$ of a $\Pi^C$ also takes this form, but differs from the streams
discussed thus far in that it is not ordered by the entailment/assertion
time of the entailed fact instances, but by the real-time associated
with the first state $\Pi^C_{i_{n}}$ in which their justification
\emph{ceases} to be complete, i.e. ${just(\Pi^C_{i_{e}}, f|t) \subseteq W^{S,r}_{i_n - 1}}$
but ${just(\Pi^C_{i_{e}}, f|t) \not\subseteq W^{S,r}_{i_n}}$.

Thus far the translation from instantaneous sets of entailments to
streams of entailments has been stated axiomatically as the definition
of those streams.  However, it can be shown from these axioms, as in
\ref{sec:semantics: proof for entailments}, that it is also possible
to reconstruct exactly the instantaneous set $E^T_{i}$, of instances
entailed at any given instant $i$ by any $\Pi^C = \{ R, F, S, r \}$,
from the sliding windows of sufficient range over its entailed streams
$P$ and $N$ at $i$:
\[ E^T_{i} = W^{P,x}_{i} \setminus W^{N,y}_{i} \]
where ${y \geq x \geq r}$. The minimum range $x$ is such to achieve
the \emph{complete} set of entailment instances $E^T_{i}$ of the
$\Pi^C_{i}$. In addition, the minimum range $y$ is such to achieve the
\emph{correct} set $E^T_{i}$. As such, a \emph{valid window} that
contains only and exactly those entailed instances $E^T_{i}$ at every
instant $i$ may be trivially maintained from the streams $P$ and $N$
continuously entailed by some $\Pi^C$.

To sum up, a time-annotated Datalog program
${\Pi^C_i = \langle R, F^0 \cup W^{S,r}_i \rangle}$ may be derived from
a continuous Datalog program ${\Pi^C = \langle R, F, S, r \rangle}$ by
applying a sliding window $W^{S,r}_i$ of range $r$ over the stream $S$ at
instant $i$ and instantiating the facts in $F$ as $F^0$. At the same time,
the entailments of a ${\Pi^C_i \vDash E^0 \cup E^T_i}$ may be derived from
the entailments of the ${\Pi^C \vDash \langle E, P, N \rangle}$ as the union
of the entailments of ${\langle R, F^0 \rangle \vDash E^0}$ and the set
difference of the windows $W^{P,r}_i$ and $W^{N,r}_i$ of range $r$ over
streams $P$ and $N$ at instant $i$.
Furthermore, a conventional Datalog program ${\Pi = \langle R, F \rangle}$
may be derived from a time-annotated Datalog program $\Pi^C_i$ by
${strip}$ping the time annotations from the set of facts
${F^0 \cup W^{S,r}_i}$, as the entailments of ${\Pi \vDash E}$ may be
derived from the entailments of $\Pi^C_i$ by $strip$ping them.
This yields the commutative diagram in \reffig{CD-TD-D}.
\begin{figure}
	\centering
	$
	\begin{CD}
		{\Pi^C = \langle R, F, S, r \rangle} @>\vDash>> {\langle E, P, N \rangle} \\
		@V{window}VV @VV{window}V \\
		{\Pi^C_i = \langle R, F^0 \cup W^{S,r}_i \rangle} @>\vDash>> {E^0 \cup E^T_i} \\
		@V{strip}VV @VV{strip}V \\
		{\Pi = \langle R, F \cup W_i \rangle} @>\vDash>> {E \cup E_i}
	\end{CD}
	$
	\caption{Commutative diagram from Continuous Datalog programs to Datalog entailments.}
	\labelfig{CD-TD-D}
\end{figure}
\end{nestedsection}
